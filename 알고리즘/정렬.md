# 정렬
## 1. 버블 정렬
- n번의 반복으로 이뤄져 있으며, 각 반복마다 연달아 있는 원소 2개의 순서가 잘못되어 있는 것을 반복하면 두 아이템을 맞 바꾸는 정렬
```python
def bubblesort(A):
  for i in range(1, len(A)):
    for j in range(0, len(A) - 1):
      if A[j] > A[j + 1]:
        A[j], A[j +1] = A[j + 1], A[j]
```
- 다른 정렬 알고리즘에 비해 현저히 좋지 않다.
- 시간 복잡도는 항상 O(n^2)
- 안정 정렬이다.

## 2. 병합 정렬
- 폰 노이만이 고안한 알고리즘으로 분할 정복을 사용
- 최선과 최악 모두 O(nlogn)의 시간복잡도
  - 대부분의 경우, 퀵 정렬보다는 느리지만 일정한 실행 속도뿐만 아니라 안정정렬이어서 상용 라이브러리에 많이 사용되고 있다.

## 3. 퀵 정렬
- 토니 호어가 고안한 알고리즘으로 피벗을 기준으로 좌우를 나누는 특징 때문에 파티션 교환 정렬이라고 불림
- 분할 정복 알고리즘이며 피벗이라는 개념을 통해 피벗보다 작으면 왼쪽, 크면 오른쪽으로 원소를 놓는다.
- 퀵 정렬 중 로무토 파티션은 항상 맨 오른쪽의 원소를 피벗으로 선택한다.
```py
def quicksort(A, lo, hi):
  def partition(lo, hi):
    pivot = A[hi]
    left = lo
    for right in range(lo,hi):
      if A[right] < pivot:
        A[left], A[right] = A[right], A[left]
        left += 1
    A[left], A[hi] = A[hi], A[left]
    return left
  
  if lo < hi:
    pivot = partition(lo, hi)
    quicksort(A, to, pivot -1)
    quicksort(A, pivot + 1, hi)
```                            
- 대부분의 경우, O(nlogn)의 시간복잡도를 가지며 병합정렬보다 빠른편이다
- 하지만 이미 정렬된 경우가 최악의 경우이며 이때, O(n^2)의 시간 복잡도를 가진다.
- 불안정 정렬이라는 단점이 있다.
- 입력값에 따라 성능의 편차가 크고 다루기가 까다롭기 때문에, 성능이 우수함에도 실무에서는 좀처럼 사용하지 않는다.

> 🍕안정 정렬 vs 불안정 정렬
> - 안정 정렬 알고리즘은 중복된 값을 입력 순서와 동일하게 정렬
> - 예를 들어, 이미 시간순 정렬이 되어 있던 데이터들에서 안정정렬을 하면 시간순 정렬을 유지한 채로 지역별 정렬이 되지만 불안정 정렬을 하면 시간순 정렬이 깨진 채로 지역별 정렬이 된다.

## 4. 삽입 정렬
- 정렬을 해야 할 대상과 정렬을 끝낸 대상, 두 그룹으로 나뉘어 정렬을 한다.
- 정렬을 해야할 대상 그룹에서 하나씩 꺼내와 정렬을 끝낸 대상 그룹에 크기를 가장 큰 수부터 비교하여 추가한다.
- 최선의 시간 복잡도는 이동 없이 비교로만 이루어진 경우로 O(n)이다
- 최악의 시간 복잡도는 입력 자료가 역순일 경우로 O(n^2)이다.
- 평균 역시 O(n^2)
## 5. 팀소트
- 삽입 정렬과 병합 정렬을 휴리스틱하게 조합한 방식
- 파이썬의 기본 정렬 알고리즘
