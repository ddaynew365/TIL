# ***프로세스와 스레드***
## ***1. 프로세스***
  - 운영체제로부터 CPU 자원을 할당받는 작업의 단위. 그리고 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)를 의미
  - Code, Data, Heap, Stack의 구조를 가지고 있다.
    - 이러한 구조로 된 독립된 메모리 영역을 할당받는다.
  - 멀티 프로세스는 IPC를 통해 서로 데이터를 주고 받는다.
### 1.1 프로세스의 문맥
- 프로세스의 현재 상태를 나타내는데 필요한 모든 요소
1. CPU와 관련된 하드웨어 문맥
  => PC, 각종 레지스터
2. 메모리와 관련된 주소 공간
  => code, data, stack
3. 프로세스 관련 커널 자료 구조
  => PCB, 커널 스택(프로세스마다 커널 스택을 가지고 있다.)

> ## 시스템콜
> 커널에서 이뤄진다
> 프로세스가 실행되다가 자신이 할 수 없는 일이 주어지면 운영체제에게 부탁하는 것(스택에 정보가 쌓인다)

## 1.2 프로세스의 상태
- Running: 실행중인 상태
- Ready: CPU를 기다리는 상태(다른 모든 조건 만족)
- Blocked: CPU를 주어도 당장 instruction을 수행할 수 없는 상태 => wait(I/O나 이벤트, 공유 데이터 접근 시 block이된다)과 sleep이 있다
- new, terminated를 추가하는 경우도 있다
> - 현재는 중기 스케줄러 때문에 Suspended(stopped)가 있다
>   => 정지가 된 상태로 메모리에서 쫒겨나 swap out 되 어 있다
>   => blocker는 자신이 요청한 event가 만족되면 ready고 suspended는 외부(중기 스케줄러)에서 정지를 시켜놨기 때문에 외부에서 정지를 풀어야 Active가 가능

## 1.3 PCB
- 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보
- 다음의 구성요소를 가진다(구조체)
1. OS가 관리상 사용하는 정보
  => 프로세스 상태, 프로세스 아이디, 스케줄링 정보, 우선순위
2. CPU 수행 관련 하드웨어 값
  => Program Counter, register
3. 메모리 관련
  => code, data, stack의 위치 정보
4. 파일 관련

## 1.4 문맥 교환
- 프로세스 입장에서 CPU를 얻었다가 뺏겼다가를 반복하는 과정이 있음
- 프로세스를 얻었다가 뺏겼을 때, 기존의 작업 상태를 알 수 있어야 함(PCB에 저장되어 있다)
- CPU가 사용자 프로세스 하나로부터 또 다른 사용자 프로세스 하나로 넘어가는 과정이 문맥교환이다
1. 사용자 프로세스A => 시스템콜, 인터럽트(커널모드) => 사용자 프로세스A는 사용자 프로세스가 변하는 것이 아니기 때문에 문맥 교환이 아니다
  - 이 때는 캐시 메모리를 지우지 않아도 된다
2. 사용자 프로세스A => 타이머 인터럽트, I/O 요청 시스템콜 => 사용자 프로세스 B 인 경우는 프로세스가 변하기 때문에 문맥교환이다.
- 사실 1번도 어느 정도 문맥의 일부를 PCB에 저장해야하지만 문맥 교환은 캐시메모리를 비우는 등, 부담이 더 크다.

## ***2. 스레드***
  - 프로세스 내에서 실행되는 여러 흐름의 단위
  - 스레드는 프로세스 내에서 각각 stack만 따로 할당 받고 code, datd, heap 영역은 공유한다.
  ### ***1-3. 멀티 스레드의 멀티 프로세스 대비 장점***
  - 프로세스를 생성하여 자원을 할당받는 [시스템 콜](./시스템콜.md)이 감소하기 때문에 자원을 효율적으로 관리 가능
  - 프로세스간 통신(IPC)보다 스레드간 통신 비용이 더 적게 발생
  - 하지만 멀티 스레드 사용시 공유자원 문제를 해결하기 위한 [동기화](./동기화.md)가 필수
