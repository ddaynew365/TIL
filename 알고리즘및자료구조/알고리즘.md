## 알고리즘 및 자료 정리
***1. 이진탐색(이분탐색)***
 - 정렬된 리스트를 탐색할 때 사용하는 알고리즘
 - 시간 복잡도는 O(logN)
 - 구현 방법은 반복문을 주로 사용

***2. dfs***
 - 그래프를 탐색할 떄 사용하는 알고리즘
 - 스택이나 재귀함수를 사용하여 주로 구현 

***3. bfs***
 - 그래프를 탐색할 떄 사용하는 알고리즘
 - 반복문과 queue를 사용하여 주로 구현

***4. 완전탐색***
- 말 글대로 모든 경우의 수를 탐색할 때 사용하는 알고리즘
- 입력값이 적을 때만 쉬운 구현 난이도로 인해 사용

***5. 그리드 알고리즘***
- 매 순간 가장 좋은 선택지만 선택하는 알고리즘
- 그리드 알고리즘을 사용할 떄는 이 문제가 매 순간 최선의 선택을 한 것만으로 최적의 해를 구할 수 있는 문제인지 증명하는 것이 중요
- 다음 두 가지 조건을 만족하여야 한다.
   1) 최적 부분 구조 - 작은 부분문에서 구한 최적의 답으로 합쳐진 큰 문제의 최적의 답을 구할 수 있어야 한다
   2) 탐욕스런 선택 조건 - 이전의 선택이 이후의 선택에 영향을 주면 안 된다

***6. 다이나믹 프로그래밍***
- DP라고 불리는 방법으로 어려운 문제 한개를 쉬운 문제 여러개로 보는 느낌의 해결법
- divide and conquer 알고리즘과 다른 점은 문제를 쪼개고 쉬운 문제 여러개의 연산 방법이 중복되어야만 사용가능하다라는 차이가 있다.
- Top down방식(하향식)과 bottom up방식(상향식)으로 나눠 생각할 수 있다. 하향식은 문제를 해결하기 바로 전부터 생각을 하여 처음부분
까지 생각하는 방식이고 상향식은 처음부터 답까지 나아가는 방식이다
- 하향식으로 생각하는 것이 DP문제임을 파악하는 데는 더 손쉽지만 재귀를 사용하고 상향식이 반복문을 사용하기에 구현에는 더 쉽다.
- 하지만 보통의 경우 하향식이 상향식보다 더 적은 연산을 하기 떄문에 하향식이 더 빠르다.

***7. 다익스트라 알고리즘***
- 특정 노드에서 다른 노드까지의 최단 거리를 구하는 알고리즘
- 우선순위 큐를 사용하면 코드로 구현할 때 좀 더 나은 시간 복잡도를 가지게 된다
- 방법은 추후 작성 필요

***8. 슬라이딩 윈도우 알고리즘***
 - 배열이나 리스트의 요소의 일정 범위의 값을 비교할때 사용하면 유용한 알고리즘
 - 중복되는 요소는 반복문에서 그대로 사용하는게 효율이 좋다
 - low값과 high값을 1씩 올리는 것을 반복

***9.크루스칼 알고리즘***
- 최소 신장 트리를 만들어내는 알고리즘으로 간선들을 가중치 기준으로 오름차순으로 정렬시킨 후 차례대로 트리에 추가하는 방법이다.
- 간선을 추가할 때, 해당 간선이 추가 됨으로써 싸이클을 만들어진다면 해당 간선을 추가하지 않는다.

***10.서로소 집합 자료구조***
- 서로소 집합 자료구조은 크루스칼 알고리즘을 코드로 구현할 떄 유용하게 쓰이는 알고리즘이다. 
- 이론부터 보자면, 두 개의 노드의 각각 루트 노드를 구하여 루트 노드가 같으면 같은 집합안에 있는 것이고 루트 노드가 서로 다르면 다른 집합안에 있다는 방법이다.
- 코드로 구현할 때는 경로 압축 방법을 사용하면 시간 복잡도를 줄일 수 있다.


***11. 다음 순열 구하는 알고리즘***
예시) 1 4 3 2   
1) 뒤에서부터 순열을 비교하며, 뒷 값이 앞 값보다 큰 경우까지 반복한다.  
   (3,2), (4,3)은 해당하지 않고,  (1,4)가 해당된다.
- 이 떄, 1의 인덱스를 x라고 칭한다.
- 4의 인덱스는 y라고 한다.
2) 다시 뒤에서부터 값을 비교하며 인덱스 x보다 큰 값이 있으면 그 값과 swap한다.
- 1과 2를 비교했고, 2가 크기 때문에 이 둘을 swap한다.
3) y에 해당되는 인덱스부터 sort를 한 뒤에 이어 붙인다.
- 4 3 1을 sorr하여 1 3 4가 된다
- 이어 붙이기 때문에 2 1 3 4가 된다.  

[출처: https://codedrive.tistory.com/386, CodeDrive님의 티스토리]

***12. 