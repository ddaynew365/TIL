## 파이썬 문법 정리

***1. from collections import deque***
 - queue를 구현할 때 사용
 - popleft()함수와 append() 함수로 추출과 삽입이 가능
 - 스택은 파이썬의 리스트를 사용하여도 무방
 - maxlen이라는 매개변수를 사용하여 큐의 최대 값을 정할 수 있다.

***2. from collecrions import defaultdict***
 - 인자로 주어진 객체의 기본값을 딕셔너리의 default 값으로 저장이 가능하다
 - 인자는 list, set, int 등등이 가능하다.( 하나의 키값에 여러개의 값을 넣고 싶을 떄 사용할 수도 있다)

***4. import heapq***
- 기본적으로 최소 힙의 구조를 따르고 있다.
- 주로 사용하는 함수로는 heapqpop() 과 heaoppush(), heapqify(), nlargest() 등이 있다.
- k(부모노드)번째 인덱스 수는 항상 2k+1, 2k+2(자식노드)번째 인덱스의 수보다 작다.
- 최소 힙이기 때문에 최솟값은 heappop()을 사용하면(첫번째 원소) 쉽게 구할 수 있지만, 최댓값은 nlargest()나 최대 힙을 만들어 연동시켜야한다.

***5. 람다식***
 - 예시) list(map(lambda x: x ** 2, range(5)))
 - 익명함수로 왼쪽은 매개변수 오른쪽은 반환되는 형태를 의미
 - map(함수, 리스트)로 리스트의 원소들을 하나씩 꺼낸 후 함수를 적용하여 다시 리스트에 집어넣는 함수다

***6. 리스트.startswith() / 리스트.endswith()***
 - 문자열의 시작과 끝 부분이 괄호 안과 일치하는지에 따라 bool값을 반환하는 함수

***7. sort(key='',reverse='')***
 - 리스트 정렬 함수
 - key는 정렬 기준을 입력할 수 있다
 - reverse는 내림차순이 되게 한다

***8. ''.join(리스트)***
 - 문자열 리스트를 하나의 문자열로 합치는 기능 

***9. all('iterable') / any('iterable')***
 - all(): 인자로 받은 데이터의 모든 요소가 True일때만 True, 요소가 비어있으면 True
 - any(): 인자로 받은 요소 중 하나라도 True면 True, 요소가 비어있으면 False

***10. property 함수***
- 해당 함수는 range의 구조가 궁금하여 선언문을 봤을 때 발견함
- 외부로부터 데이터를 보호하기 위한 getter, setter을 실제로는 썻지만 마치 안 쓴것처럼 보이게 하는 기능을 가지고 있다.(delete도 포함)
- 예시)
class Person:
    def __init__(self, first_name, last_name, age):
        self.first_name = first_name
        self.last_name = last_name
        self.age = age

    def get_age(self):
        return self._age

    def set_age(self, age):
        if age < 0:
            raise ValueError("Invalid age")
        self._age = age

    age = property(get_age, set_age)
    
- property 데코레이터도 존재(@property)
- 이 경우는 함수명의 get_와 set_을 생략가능하게 해줌
- 에시)
class Person:
    def __init__(self, first_name, last_name, age):
        self.first_name = first_name
        self.last_name = last_name
        self.age = age

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, age):
        if age < 0:
            raise ValueError("Invalid age")
        self._age = age
        
***11. divmod(a,b)***
- a를 b로 나누었을 때 몫과 나머지를 계산하는 함수
- 밑에 쓰여진 *divmod(a,b)를 사용하면 몫과 나머지가 따로 나오게 할 수 있다

***13. * 연산자 - unpacking***
- 단순 곱하기 연산으로도 사용 가능하지만 함수의 인자로 쓰일 때 변수 앞에 써놓으면 unpacking해서 값이 들어간다

***15. int("3212",2)***
- int() 함수를 위와 같이 쓰면 해당 문자열의 수를 2진법으로 표현할 수 있다.

***17. ljust(), rjust(), center()***
- print()함수를 쓸 때 해당 함수를 쓰면 왼쪽, 가운데, 오른쪽 정렬이 가능하다

***19. strip()***
- 인자안의 값이 문자열에서 가장 끝 부분에 있다면 제거해준다.

***21. string 모듈***
- string.ascii_lowercase 나 string.ascii_uppercase같은 것을 사용하면 알파벳을 꺼낼 수 있다(문자열)

***23. zip()***
- 인자안의 값들을 packing하는 함수다
- list(map(list, zip(*mylist)))를 사용하면 이차원 리스트의 열과 행을 바꿀 수 있다
- dict(zip(animals, sounds))같은 방법으로 리스트 2개를 딕셔너리로 바꿀 수도 있다

***24. 제곱수 판별하기***
- if math.sqrt(a) == int(math.sqrt(a)):

***25. 딕셔너리 값으로 키 찾기***
- items() 사용

***26. bisect***
- 이진 탐색을 가능하게 해준다
- bisect.bisect(a, 3)

***27. __str__ 함수***
- 클래스의 내부에서 출력 format을 설정하는 함수

***28. inf***
- 파이썬에서 그 어떤 수보다 크다고 인식
- 예시) int('inf')

***29. 리스트.count(값)***
- 리스트안의 값의 개수를 구할 수 있는 함수

***31. graph = [ [] for _ in range(n + 1)]***
    for f, to in edge:
        graph[f].append(to)
        graph[to].append(f)
- 단순히 간선만 주어진 문제에서 index별로 목표를 가리키는 그래프 리스트로 만들어주는 코드 예시다.

***32.복사***
- 단순 복사: 파이썬의 단순 복사('='연산자)는 같은 객체를 바라보게 하는 것
- 얕은 복사: 얕은 복사는 슬라이싱과 '='연산자 또는 copy() 또는 copy.copy() 등이 있는데 이는 새로운 객체를 만들어 주소를 할당한다. 하지만 자식객체들은 얕은 복사당한 객체의 자식 객체              들과 같은 객체를 바라보고 있다
- 깊은 복사: 깊은 복사는 copy.deepcopy()를 사용하는데 이는 위의 얕은 복사에서 자식 객체들까지 새로운 객체에 주소를 할당한 것이다.

***33.함수 리스트(객체) 매개변수***
- 파이썬에서는 모든 변수가 객체로 간주된다.(동적이기때문에) 따라서 모든 경우에서 call by reference로 인식된다
- 하지만 int, tuple, 문자열은 immutabel이기 때문에  함수에서 받아올 떄 새로운 주소로 할당이되고 call by value처럼 보이는 것
- 리스트, 딕셔너리, set은 mutable이기 때문에 그대로 call by reference로 인식

***
***
        

## 자료구조 정리
***1. 큐***
- 선입선출이라는 특성을 가진 자료구조이다.
- 큐의 데이터 삽입, 삭제가 빠르다
- 주로 데이터를 입력받은데로 처리할 때나 bfs 알고리즘에 많이 사용된다.

***2. 스택***
- 선입후출이라는 구조를 가진 자료구조이다.
- 맨 위의 요소에만 접근 가능하다.
- 역추적이나 재귀 알고리즘에서 유용하게 사용가능하다.

***3. 해시***

***4. 힙***

***6. 덱(deque)***

***
***

## 알고리즘 및 자료 정리
***1. 이진탐색(이분탐색)***
 - 정렬된 리스트를 탐색할 때 사용하는 알고리즘
 - 시간 복잡도는 O(logN)
 - 구현 방법은 반복문을 주로 사용

***2. dfs***
 - 그래프를 탐색할 떄 사용하는 알고리즘
 - 스택이나 재귀함수를 사용하여 주로 구현 

***3. bfs***
 - 그래프를 탐색할 떄 사용하는 알고리즘
 - 반복문과 queue를 사용하여 주로 구현

***4. 완전탐색***
- 말 글대로 모든 경우의 수를 탐색할 때 사용하는 알고리즘
- 입력값이 적을 때만 쉬운 구현 난이도로 인해 사용

***5. 그리드 알고리즘***
- 매 순간 가장 좋은 선택지만 선택하는 알고리즘
- 그리드 알고리즘을 사용할 떄는 이 문제가 매 순간 최선의 선택을 한 것만으로 최적의 해를 구할 수 있는 문제인지 증명하는 것이 중요

***6. 다이나믹 프로그래밍***
- DP라고 불리는 방법으로 어려운 문제 한개를 쉬운 문제 여러개로 보는 느낌의 해결법
- divide and conaquer 알고리즘과 다른 점은 문제를 쪼개고 쉬운 문제 여러개의 연산 방법이 중복되어야만 사용가능하다라는 차이가 있다.

***7. 다익스트라 알고리즘***
- 특정 노드에서 다른 노드까지의 최단 거리를 구하는 알고리즘
- 우선순위 큐를 사용하면 코드로 구현할 때 좀 더 나은 시간 복잡도를 가지게 된다
- 방법은 추후 작성 필요

***8. 슬라이딩 윈도우 알고리즘***
 - 배열이나 리스트의 요소의 일정 범위의 값을 비교할때 사용하면 유용한 알고리즘
 - 중복되는 요소는 반복문에서 그대로 사용하는게 효율이 좋다
 - low값과 high값을 1씩 올리는 것을 반복

***9.크루스칼 알고리즘***
- 최소 신장 트리를 만들어내는 알고리즘으로 간선들을 가중치 기준으로 오름차순으로 정렬시킨 후 차례대로 트리에 추가하는 방법이다.
- 간선을 추가할 때, 해당 간선이 추가 됨으로써 싸이클을 만들어진다면 해당 간선을 추가하지 않는다.

***10.서로소 집합 자료구조***
- 서로소 집합 자료구조은 크루스칼 알고리즘을 코드로 구현할 떄 유용하게 쓰이는 알고리즘이다. 
- 이론부터 보자면, 두 개의 노드의 각각 루트 노드를 구하여 루트 노드가 같으면 같은 집합안에 있는 것이고 루트 노드가 서로 다르면 다른 집합안에 있다는 방법이다.
- 코드로 구현할 때는 경로 압축 방법을 사용하면 시간 복잡도를 줄일 수 있다.

***
***

## 그 외 SW 공부
***1. 스케줄링***
 - 비선점 스케줄링
    - FCFS : 선입선출 형식으로 스케줄링
    - SPN : 처리시간이 짧은 프로세스부터 먼저 스케줄링(기아 현상이 발생할 수 있다.)
    - HRRN : 응답률이라는 식을 만들어 응답률이 높은 프로세스부터 스케줄링(기아현상을 예방할 수 있다.)
 - 선점 스케줄링
    - Round-Robin : FCFS 방식 기반에 CPU가 할당한 시간이 지나면 작업을 뺏어가고 다음 프로세스에게 넘겨주는 스케줄링(기아 현상은 예방하지만 context switch에서 오버헤드가 발생할 수있다.)
    - SRT : SPN과 유사하나 선점이 가능한 스케줄링(기아 현상이 발생할 수 있다.)
    - Multi-process queue : 우선순위별로 프로세스를 서로 다른 큐에 집어넣고 우선순위가 높은 큐부터 스케줄링

***2. 페이지 교체 알고리즘***
- FIFO : 페이지가 주기억장치에 등록된 시간을 기준으로 교체될 페이지를 선정하는 기법
         단점: 중요한 페이지가 오래 있었다는 이유만으로 교체되는 경우가 발생할 수 있음
- LFU : 가장 적은 횟수를 참조하는 페이지를 교체하는 기법
        단점: 참조될 가능성이 앞으로 많은 페이지가 불합리되게 교체되는 경우가 발생할 수 있음
- LRU : 가장 오랫동안 참조되지 않은 페이지를 교체하는 기법
        단점: 프로세스가 주기억장치에 접근할 때마다 참조된 페이지에 대한 시간을 기록해야함. 큰 오버헤드가 발생
        

