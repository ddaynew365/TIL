## 1. TCP / UDP
- TCP는 연결지향형 전송규약
  - 흐름 중심 프로토코, 통신을 주고받는 것을 중요 사항
  - 중간 패킷이 손실되는 경우 재선송을 통해 신뢰성을 보장함(느림)
  - 대부분의 통신에서 사용됨, 특히 파일이안 데이터 전송시에 사용
  - 바이트 스트림 서비스로 데이터 경계 구분이 없다
  - 세그먼트, 패킷
  - HTTP, 메일, 파일에 사용

- UDP는 손실을 일부 허용
  - 비연결지향형 전송규약
  - 데이터 중심 프로토콜, 주고받는 통신보다 데이터를 일방적으로 보내는 것을 중요시함
    - 데이터 전송의 신뢰성을 보장하지 않음(빠름)
  - P2P, 스트리밍, 전화에 사용
  - 데이터그램: 독립적인 관계를 지니는 패킷
  
## 2. 3-Handshaking과 4-Handshaking
- 3-Handshaking
  - TCP에 쓰이는 연결 설정
  - TCP의 3-way Handshaking 과정
  ```
  [STEP 1]
  A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 되는 것이다.
  [STEP 2] 
  B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.
  [STEP 3]
  A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 B서버 상태가 ESTABLISHED 이다.
  ```

- 4-Handshaking
  - 요청을 마치는 연결 설정
  - TCP의 4-way Handshaking 과정
  ```
  [STEP 1]
  클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다.

  [STEP 2] 
  서버는 일단 확인메시지를 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 TIME_WAIT상태다.
  
  [STEP 3]
  서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송한다.

  [STEP 4]
  클라이언트는 확인했다는 메시지를 보낸다.
  ```
  ```
  Q. 3-H / 네 번째 줄에서, 클라이언트가 서버가 보낸 ACK+SYC를 받지 못하면?

  A. 두 번째 줄에서 클라이언트는 서버로 SYC를 보내고 시간을 잰다. Timeout이 되기 전까지 ACK+SYC가 오지 않으면, 다시 SYC를 보내고 ACK+SYC 수신을 대기한다.

  

  Q. 4-H / 서버가 마지막에 FIN을 보내는 이유?

  A. 서버가 아직 클라이언트에 보낼 데이터가 남아있을 경우 데이터를 다 전송하지도 못한 채 클라이언트 에서 포트를 닫아버리게 되므로 서버 또한 종료될 준비가 되었다는 의미로 FIN을 보냄

  

  Q. 4-H / 클라이언트가 마지막에 ACK를 굳이 보내는 이유?

  A. 서버가 보낸 FIN을 클라이언트가 받지 못하면 클라이언트는 FIN_WAIT_2 상태로 종료가 되지 못한 채 계속 기다려야 한다. 하지만 서버는 이미 포트를 닫고 더는 응답을 하지 않는 상태이기에 클라이 언트는 불필요한 자원을 소모할 수 있음

  

  Q. HTTPS 환경에서의 3-H
  A.
    1. Client -> Server : SSL정보 및 암호화방식, 무작위 바이트 문자열(A)
    2. Server -> Client : 인증서, 무작위 바이트 문자열(B)
    3. Client가 CA에 인증서 목록에 있는지 확인 후 있다면 공개키 받음
    4. Client -> Server : 무작위 바이트 문자열 A와 B를 조합, 공개키로 암호화하여 전송
    5. Server에서 비밀키로 받은 무작위 바이트 문자열 조합을 복호화, 이것으로 session key를 만듦 - 해당 session key를 가지고 암호화한 데이터를 주고받음
  ```

  아파치 - 멀티 쓰레드 형식 - 요청마다 쓰레드 생성 -> 10000명만 들어와도 터짐
  엔진엑스 - 이벤트 드라이븐 형식


  흐름 제어
  혼잡 제어
  혼잡 제어는 트래픽이 몰려서 과부하가 일어날 수 있기 때문에 트래픽을 조절해주는 것
  흐름제어는 너무 많은 데이터를 전송할 때, 데이터의 순서를 맞추기 위한 것

  - 어떤 이유 때문에 순서를 맞추죠?
    - 데이터의 순서를 보장해주기 위해서 흐름 제어를 합니다.
  - 데이터 전송 속도가 빠르면 순서 맞추기에 어떤 일이 일어나죠?
    - 잘 모르겠습니다.
    - 속도가 빠르면, 수신자의 데이터 처리 속도가 떨어져 버퍼가 넘쳐 흘러 데이터 손실이 발생한다. 데이터 순서도 마찬가지
    - 따라서 데이터를 보낼 때, 일정 데이터의 수를 정해놔서 위의 문제를 예방한다.
  - 저희가 서비스를 만드는데 구글 로그인이 가능하네요? 어떤 기술이죠? 
    - 구글 oauth를 사용하여 기능을 구현할 것 같습니다.
  - oauth가 뭐죠?
    - 인증을 해주는 걸로 알고있다.
  - 어떤 인증을 해주죠?
    - 사용자의 정보를 인증해준다고 생각합니다.
  - 로그인과 같은 기능인가요?
    - 우리 서비스에서 그 기업의 로그인을
  - 사용자가 서비스에 요청하면 권한을 누구에게 주나요?
    - 키값으로 우리 서버에서 사용자 인증을 할 수 있습니다.
  - 제가 잘 몰라서 그러는데 flow좀 그려주세요
    - 버튼 클릭 -> 구글로 redirect -> 사용자 구글 로그인 -> 인증이 성공적이면 우리 서버에 인증키를 줌 -> 인증키를 통해서 사용자의 구글 정보를 가져옴 -> 정보를 통해서 우리 서버에서 사용
  - 서버는 어떻게 사용자 정보를 가져오죠?
    - ~서버로 인증키값을 보내는데 그 인증 키값으로 구글의 정보를 가져올 수 있습니다.
  - 그 키가 어떤건지 정확히 말해줄 수 있나요?
    - 인증키로 access token
  - 그러면 로그인할 때, 사용되는 비밀번호는 아닌거죠?
    - 네 아닙니다.

- 서비스 사용경험?
- 서비스 구성 요소?
- 타입스크립트
  - 제네릭 사용 이유?
  - HTTP3에 대해서
  - type safe: 타입을 판별할 수 있어 runtime시가 아닌 컴파일시 문제를 잡을 수 있는 것
